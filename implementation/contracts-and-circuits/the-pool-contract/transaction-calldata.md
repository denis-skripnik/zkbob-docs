---
description: Reference tables with calldata structure for different transaction types
---

# Transaction Calldata

All transaction data are transferred to the Pool contract through the calldata. The following reference table is useful for transaction analysis.

Withdrawal transactions contain addition fields `memo.nativeamount` and `memo.receiver` . Due to this, the calldata table for withdrawal transactions is presented separately.

{% tabs %}
{% tab title="Deposit\Transfer" %}
<table><thead><tr><th width="150.3351011589079">Field</th><th width="150">Size (bytes)</th><th width="150">Offset (bytes)</th><th>Description</th></tr></thead><tbody><tr><td>selector</td><td>4</td><td>0</td><td>Contract method selector (0xaf989083)</td></tr><tr><td>nullifier</td><td>32</td><td>4</td><td>The unique <a href="../../transaction-overview/the-nullifiers.md">transaction nullifier</a></td></tr><tr><td>out_commit</td><td>32</td><td>36</td><td>Transaction commitment (transaction subtree root in the <a href="../../untitled/">Merkle tree</a>)</td></tr><tr><td>tx_index</td><td>6</td><td>68</td><td>Transaction's first leaf index within Merkle tree (0-based counter)</td></tr><tr><td>energy_amount</td><td>14</td><td>74</td><td>Account XP delta (signed integer, Gwei)</td></tr><tr><td>token_amount</td><td>8</td><td>88</td><td>Account token delta (signed integer, Gwei)</td></tr><tr><td>tx_proof</td><td>256</td><td>96</td><td>zkSNARK proof</td></tr><tr><td>root_after</td><td>32</td><td>352</td><td>Merkle tree root after adding the transaction</td></tr><tr><td>tree_proof</td><td>256</td><td>384</td><td>zkSNARK proof</td></tr><tr><td>tx_type</td><td>2</td><td>640</td><td><p>0 - deposit</p><p>1 - transfer</p><p>2 - withdraw</p></td></tr><tr><td>memo_size</td><td>2</td><td>642</td><td>The following memo block size in bytes</td></tr><tr><td>memo.fee</td><td>8</td><td>644</td><td>The tokens amount to be transferred to the operator (the Pool contract will multiply the fee by denominator)</td></tr><tr><td>memo.ItemsNum</td><td>4</td><td>652</td><td>Number of encrypted items in the memo block</td></tr><tr><td>memo.Hash_acc</td><td>32</td><td>656</td><td>Output account hash (with updated balance)</td></tr><tr><td>memo.Hash_notes</td><td>32 * (memo.ItemsNum - 1)</td><td>688</td><td>Output note hash</td></tr><tr><td>memo.Ap_x</td><td>32</td><td>656 + 32 ∗ memo.ItemsNum</td><td>Ephemeral public key (using to decrypt <code>memo.keys_enc</code> by transaction sender)</td></tr><tr><td>memo.keys_enc</td><td>32 * memo.ItemsNum + 16</td><td>688+ 32 ∗ memo.ItemsNum</td><td>Account and notes encryption keys</td></tr><tr><td>memo.acc_enc</td><td>86</td><td>704 + 64 * memo.ItemsNum</td><td>Encrypted account with an updated balance</td></tr><tr><td>memo.notes_enc</td><td>108*(memo.ItemsNum - 1)</td><td>790+ 64 * memo.ItemsNum</td><td><p>A single encrypted note  <span class="math">(A_i, Note_i^{enc})</span> takes 108 bytes:</p><p><span class="math">sizeof(A_i)</span>= 32<br><span class="math">sizeof(Note_i^{enc})</span>= 76</p></td></tr><tr><td>ECDSA signature <code>(r, s)</code></td><td>64</td><td>682 + 172 * memo.ItemsNum</td><td>Used to recover deposit spender in the corresponding transactions</td></tr></tbody></table>
{% endtab %}

{% tab title="Withdrawal" %}
<table><thead><tr><th width="150.3351011589079">Field</th><th width="150">Size (bytes)</th><th width="150">Offset (bytes)</th><th>Description</th></tr></thead><tbody><tr><td>selector</td><td>4</td><td>0</td><td>Contract method selector (0xaf989083)</td></tr><tr><td>nullifier</td><td>32</td><td>4</td><td>The unique <a href="../../transaction-overview/the-nullifiers.md">transaction nullifier</a></td></tr><tr><td>out_commit</td><td>32</td><td>36</td><td>Transaction commitment (transaction subtree root in the <a href="../../untitled/">Merkle tree</a>)</td></tr><tr><td>tx_index</td><td>6</td><td>68</td><td>Transaction's first leaf index within Merkle tree (0-based counter)</td></tr><tr><td>energy_amount</td><td>14</td><td>74</td><td>Account energy delta (signed integer, Gwei)</td></tr><tr><td>token_amount</td><td>8</td><td>88</td><td>Account token delta (signed integer, Gwei)</td></tr><tr><td>tx_proof</td><td>256</td><td>96</td><td>zkSNARK proof</td></tr><tr><td>root_after</td><td>32</td><td>352</td><td>Merkle tree root after adding the transaction</td></tr><tr><td>tree_proof</td><td>256</td><td>384</td><td>zkSNARK proof</td></tr><tr><td>tx_type</td><td>2</td><td>640</td><td><p>0 - deposit</p><p>1 - transfer</p><p>2 - withdraw</p></td></tr><tr><td>memo_size</td><td>2</td><td>642</td><td>The following memo block size in bytes</td></tr><tr><td>memo.fee</td><td>8</td><td>644</td><td>The tokens amount to be transferred to the operator (the Pool contract will multiply the fee by denominator)</td></tr><tr><td><em>memo.nativeamount</em></td><td>8</td><td>652</td><td>Count of the native coin to withdraw</td></tr><tr><td><em>memo.receiver</em></td><td>20</td><td>660</td><td>Destination native address for withdrawal</td></tr><tr><td>memo.ItemsNum</td><td>4</td><td>680</td><td>Number of encrypted items in the memo block</td></tr><tr><td>memo.Hash_acc</td><td>32</td><td>684</td><td>Output account hash (with updated balance)</td></tr><tr><td>memo.Hash_notes</td><td>32 * (memo.ItemsNum - 1)</td><td>716</td><td>Output note hash</td></tr><tr><td>memo.Ap_x</td><td>32</td><td>684 + 32 ∗ memo.ItemsNum</td><td>Ephemeral public key (using to decrypt <code>memo.keys_enc</code> by transaction sender)</td></tr><tr><td>memo.keys_enc</td><td>32 * memo.ItemsNum + 16</td><td>716 + 32 ∗ memo.ItemsNum</td><td>Account and notes encryption keys</td></tr><tr><td>memo.acc_enc</td><td>86</td><td>732 + 64 * memo.ItemsNum</td><td>Encrypted account with an updated balance</td></tr><tr><td>memo.notes_enc</td><td>108*(memo.ItemsNum - 1)</td><td>818 + 64 * memo.ItemsNum</td><td><p>A single encrypted note  <span class="math">(A_i, Note_i^{enc})</span> takes 108 bytes:</p><p><span class="math">sizeof(A_i)</span>= 32<br><span class="math">sizeof(Note_i^{enc})</span>= 76</p></td></tr><tr><td>ECDSA signature <code>(r, s)</code></td><td>64</td><td>710 + 172 * memo.ItemsNum</td><td>Used to recover deposit spender in the corresponding transactions</td></tr></tbody></table>


{% endtab %}
{% endtabs %}
